1.객체지향설계원칙(SOLID)
=======================
### 1)Single Responsible Principle(단일 책임 원칙)
> 하나의 객체는 하나의 책임만을 지녀야 한다는 법칙
```python
# AS-IS
  class Employee:
    print('Doing Coding')
  
  def design(self):
    print('Doing Design')
  
  def analyze(self):
    print('Doing Analyze')

# TO-BE
  class Developer:
    def coding(self):
      print('Doing Coding')
  
  class Designer:
    def design(self):
      print('Doing Design')
  
  class Analyst:
    def analyze(self):
      print('Doing Analyze')
```

### 2)Open-Closed Principle(개방-폐쇄 원칙)
> 객체의 확장에는 열려있고, 수정에는 닫혀있어야 한다는 법칙</br>
> 기존 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계</br>
> 이를 위해서, 인터페이스나 추상 클래스를 통하여 객체를 추상화시키고 이를 상속하거나 구현하도록 한다</br>
> 스프링에서도 강조되는 원칙인데, Interface를 먼저 구현해놓고 인스턴스를 구현하여 필요한 기능들을 만든다.
```python
# AS-IS
class Employee:
    print('Doing Coding')
  
  def design(self):
    print('Doing Design')
  
  def analyze(self):
    print('Doing Analyze')
  
  class Company:
    def __init__(self, employees):
      self.employees = employees
    
    def make_work(self):
      for employee in self.employees:
        if isinstance(employee, Developer):
          employee.coding()
        elif isinstance(employee, Designer):
          employee.design()
        elif isinstance(employee, Analyst):
          employee.analyze()
#TO-BE
# 각 객체들의 역할을 아우르는 추상 클래스(고수준)을 생성합니다.
class Employee(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def work(self):
        ...

class Developer(Employee):
    def work(self):
        print("코딩을 합니다")

class Designer(Employee):
    def work(self):
        print("디자인을 합니다")

class Analyst(Employee):
    def work(self):
        print("분석을 합니다")

#상속을 통해 쉽게 구현이 가능함 -> 확장에 열려있다.
class Manager(Employee):
    def work(self):
		print("매니징을 합니다")

class Company:
    def __init__(self, employees: List[Employee]):
        self.employees = employees

    # employee가 늘어나더라도 변경에는 닫혀있다.
    def make_work(self):
        for employee in self.employees:
            employee.work()
```
